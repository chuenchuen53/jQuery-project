//@ts-check

class KeyData {
  static data = Object.freeze({
    0: {
      key: "0",
      code: "Digit0",
      shiftKey: false,
      finger: "rightLittle",
      shiftFinger: "",
      type: "digit",
    },
    1: {
      key: "1",
      code: "Digit1",
      shiftKey: false,
      finger: "leftLittle",
      shiftFinger: "",
      type: "digit",
    },
    2: {
      key: "2",
      code: "Digit2",
      shiftKey: false,
      finger: "leftRing",
      shiftFinger: "",
      type: "digit",
    },
    3: {
      key: "3",
      code: "Digit3",
      shiftKey: false,
      finger: "leftMiddle",
      shiftFinger: "",
      type: "digit",
    },
    4: {
      key: "4",
      code: "Digit4",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "digit",
    },
    5: {
      key: "5",
      code: "Digit5",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "digit",
    },
    6: {
      key: "6",
      code: "Digit6",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "digit",
    },
    7: {
      key: "7",
      code: "Digit7",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "digit",
    },
    8: {
      key: "8",
      code: "Digit8",
      shiftKey: false,
      finger: "rightMiddle",
      shiftFinger: "",
      type: "digit",
    },
    9: {
      key: "9",
      code: "Digit9",
      shiftKey: false,
      finger: "rightRing",
      shiftFinger: "",
      type: "digit",
    },
    q: {
      key: "q",
      code: "KeyQ",
      shiftKey: false,
      finger: "leftLittle",
      shiftFinger: "",
      type: "alphabet",
    },
    a: {
      key: "a",
      code: "KeyA",
      shiftKey: false,
      finger: "leftLittle",
      shiftFinger: "",
      type: "alphabet",
    },
    z: {
      key: "z",
      code: "KeyZ",
      shiftKey: false,
      finger: "leftLittle",
      shiftFinger: "",
      type: "alphabet",
    },
    w: {
      key: "w",
      code: "KeyW",
      shiftKey: false,
      finger: "leftRing",
      shiftFinger: "",
      type: "alphabet",
    },
    s: {
      key: "s",
      code: "KeyS",
      shiftKey: false,
      finger: "leftRing",
      shiftFinger: "",
      type: "alphabet",
    },
    x: {
      key: "x",
      code: "KeyX",
      shiftKey: false,
      finger: "leftRing",
      shiftFinger: "",
      type: "alphabet",
    },
    e: {
      key: "e",
      code: "KeyE",
      shiftKey: false,
      finger: "leftMiddle",
      shiftFinger: "",
      type: "alphabet",
    },
    d: {
      key: "d",
      code: "KeyD",
      shiftKey: false,
      finger: "leftMiddle",
      shiftFinger: "",
      type: "alphabet",
    },
    c: {
      key: "c",
      code: "KeyC",
      shiftKey: false,
      finger: "leftMiddle",
      shiftFinger: "",
      type: "alphabet",
    },
    r: {
      key: "r",
      code: "KeyR",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    f: {
      key: "f",
      code: "KeyF",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    v: {
      key: "v",
      code: "KeyV",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    t: {
      key: "t",
      code: "KeyT",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    g: {
      key: "g",
      code: "KeyG",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    b: {
      key: "b",
      code: "KeyB",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    y: {
      key: "y",
      code: "KeyY",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    h: {
      key: "h",
      code: "KeyH",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    n: {
      key: "n",
      code: "KeyN",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    u: {
      key: "u",
      code: "KeyU",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    j: {
      key: "j",
      code: "KeyJ",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    m: {
      key: "m",
      code: "KeyM",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    i: {
      key: "i",
      code: "KeyI",
      shiftKey: false,
      finger: "rightMiddle",
      shiftFinger: "",
      type: "alphabet",
    },
    k: {
      key: "k",
      code: "KeyK",
      shiftKey: false,
      finger: "rightMiddle",
      shiftFinger: "",
      type: "alphabet",
    },
    ",": {
      key: ",",
      code: "Comma",
      shiftKey: false,
      finger: "rightMiddle",
      shiftFinger: "",
      type: "symbol",
    },
    o: {
      key: "o",
      code: "KeyO",
      shiftKey: false,
      finger: "rightRing",
      shiftFinger: "",
      type: "alphabet",
    },
    l: {
      key: "l",
      code: "KeyL",
      shiftKey: false,
      finger: "rightRing",
      shiftFinger: "",
      type: "alphabet",
    },
    ".": {
      key: ".",
      code: "Period",
      shiftKey: false,
      finger: "rightRing",
      shiftFinger: "",
      type: "symbol",
    },
    p: {
      key: "p",
      code: "KeyP",
      shiftKey: false,
      finger: "rightLittle",
      shiftFinger: "",
      type: "alphabet",
    },
    ";": {
      key: ";",
      code: "Semicolon",
      shiftKey: false,
      finger: "rightLittle",
      shiftFinger: "",
      type: "symbol",
    },
    "/": {
      key: "/",
      code: "Slash",
      shiftKey: false,
      finger: "rightLittle",
      shiftFinger: "",
      type: "symbol",
    },
    "!": {
      key: "!",
      code: "Digit1",
      shiftKey: true,
      finger: "leftLittle",
      shiftFinger: "right",
      type: "symbol",
    },
    Q: {
      key: "Q",
      code: "KeyQ",
      shiftKey: true,
      finger: "leftLittle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    A: {
      key: "A",
      code: "KeyA",
      shiftKey: true,
      finger: "leftLittle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    Z: {
      key: "Z",
      code: "KeyZ",
      shiftKey: true,
      finger: "leftLittle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    "@": {
      key: "@",
      code: "Digit2",
      shiftKey: true,
      finger: "leftRing",
      shiftFinger: "right",
      type: "symbol",
    },
    W: {
      key: "W",
      code: "KeyW",
      shiftKey: true,
      finger: "leftRing",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    S: {
      key: "S",
      code: "KeyS",
      shiftKey: true,
      finger: "leftRing",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    X: {
      key: "X",
      code: "KeyX",
      shiftKey: true,
      finger: "leftRing",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    "#": {
      key: "#",
      code: "Digit3",
      shiftKey: true,
      finger: "leftMiddle",
      shiftFinger: "right",
      type: "symbol",
    },
    E: {
      key: "E",
      code: "KeyE",
      shiftKey: true,
      finger: "leftMiddle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    D: {
      key: "D",
      code: "KeyD",
      shiftKey: true,
      finger: "leftMiddle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    C: {
      key: "C",
      code: "KeyC",
      shiftKey: true,
      finger: "leftMiddle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    $: {
      key: "$",
      code: "Digit4",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "symbol",
    },
    R: {
      key: "R",
      code: "KeyR",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    F: {
      key: "F",
      code: "KeyF",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    V: {
      key: "V",
      code: "KeyV",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    "%": {
      key: "%",
      code: "Digit5",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "symbol",
    },
    T: {
      key: "T",
      code: "KeyT",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    G: {
      key: "G",
      code: "KeyG",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    B: {
      key: "B",
      code: "KeyB",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    "^": {
      key: "^",
      code: "Digit6",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "symbol",
    },
    Y: {
      key: "Y",
      code: "KeyY",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    H: {
      key: "H",
      code: "KeyH",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    N: {
      key: "N",
      code: "KeyN",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    "&": {
      key: "&",
      code: "Digit7",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "symbol",
    },
    U: {
      key: "U",
      code: "KeyU",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    J: {
      key: "J",
      code: "KeyJ",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    M: {
      key: "M",
      code: "KeyM",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    "*": {
      key: "*",
      code: "Digit8",
      shiftKey: true,
      finger: "rightMiddle",
      shiftFinger: "left",
      type: "symbol",
    },
    I: {
      key: "I",
      code: "KeyI",
      shiftKey: true,
      finger: "rightMiddle",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    K: {
      key: "K",
      code: "KeyK",
      shiftKey: true,
      finger: "rightMiddle",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    "<": {
      key: "<",
      code: "Comma",
      shiftKey: true,
      finger: "rightMiddle",
      shiftFinger: "left",
      type: "symbol",
    },
    "(": {
      key: "(",
      code: "Digit9",
      shiftKey: true,
      finger: "rightRing",
      shiftFinger: "left",
      type: "symbol",
    },
    O: {
      key: "O",
      code: "KeyO",
      shiftKey: true,
      finger: "rightRing",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    L: {
      key: "L",
      code: "KeyL",
      shiftKey: true,
      finger: "rightRing",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    ">": {
      key: ">",
      code: "Period",
      shiftKey: true,
      finger: "rightRing",
      shiftFinger: "left",
      type: "symbol",
    },
    ")": {
      key: ")",
      code: "Digit0",
      shiftKey: true,
      finger: "rightLittle",
      shiftFinger: "left",
      type: "symbol",
    },
    P: {
      key: "P",
      code: "KeyP",
      shiftKey: true,
      finger: "rightLittle",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    ":": {
      key: ":",
      code: "Semicolon",
      shiftKey: true,
      finger: "rightLittle",
      shiftFinger: "left",
      type: "symbol",
    },
    "?": {
      key: "?",
      code: "Slash",
      shiftKey: true,
      finger: "rightLittle",
      shiftFinger: "left",
      type: "symbol",
    },
  });

  constructor() {}

  /**
   *
   * @param {string} key
   * @returns {string}
   */
  static getFinger(key) {
    return KeyData.data[key]?.finger ?? "";
  }
}

class LetterGenerator {
  /** @private @type {Record<string, boolean>} */ static availableLetters = {};

  /**
   * @private
   * @typedef {"leftLittle" | "leftRing" | "leftMiddle" | "leftIndex" | "rightIndex" | "rightMiddle" | "rightRing" | "rightLittle"} LetterGeneratorDataKey
   * @typedef {Record<LetterGeneratorDataKey, string[]>} LetterGeneratorData
   * @type {LetterGeneratorData}
   */
  static data = {
    leftLittle: [],
    leftRing: [],
    leftMiddle: [],
    leftIndex: [],
    rightIndex: [],
    rightMiddle: [],
    rightRing: [],
    rightLittle: [],
  };

  /** @public @type {LetterGeneratorDataKey[]} */ static activeFingers = ["leftLittle", "leftRing", "leftMiddle", "leftIndex", "rightIndex", "rightMiddle", "rightRing", "rightLittle"];

  constructor() {
    for (let key in KeyData.data) {
      LetterGenerator.availableLetters[key] = true;
      LetterGenerator.data[KeyData.data[key].finger].push(key);
    }
  }

  /**
   * @public
   * @return {Readonly<LetterGeneratorData>}
   */
  getAllDate() {
    return this.cloneReadonlyObject(LetterGenerator.data);
  }

  /**
   * @public
   * @param {LetterGeneratorDataKey} dataKey
   * @return {readonly string[]}
   */
  getOneFingerDate(dataKey) {
    return this.cloneReadonlyObject(LetterGenerator.data[dataKey]);
  }

  /**
   * @public
   * @param {Record<string, boolean>} newAvailableLetters
   * @return {void}
   */
  updateData(newAvailableLetters) {
    for (let key in newAvailableLetters) {
      LetterGenerator.availableLetters[key] = newAvailableLetters[key];
    }
    for (let key in LetterGenerator.data) {
      LetterGenerator.data[key] = [];
    }
    for (let key in KeyData.data) {
      if (LetterGenerator.availableLetters[key]) {
        const finger = KeyData.data[key].finger;
        LetterGenerator.data[finger].push(key);
      }
    }
  }

  /**
   * @public
   * @param {number} numberOfLetters
   * @returns {{finger: LetterGeneratorDataKey, letter: string}[]}
   */
  generateRandomLetter(numberOfLetters) {
    const letters = [];
    for (let i = 0; i < numberOfLetters; i++) {
      letters.push(LetterGenerator.randomLetter());
    }
    return letters;
  }

  /**
   * @private
   * @template T
   * @param {T} obj
   * @return {T}
   */
  cloneObject(obj) {
    const objClone = JSON.parse(JSON.stringify(obj));
    return objClone;
  }

  /**
   * @private
   * @template T
   * @param {T} obj
   * @return {Readonly<T>}
   */
  cloneReadonlyObject(obj) {
    const objClone = Object.freeze(this.cloneObject(obj));
    return objClone;
  }

  /**
   * @template T
   * @param {T[]} array
   * @returns {T}
   */
  static randomItemFromArray(array) {
    return array[Math.floor(Math.random() * array.length)];
  }

  /**
   * @private
   * @returns {LetterGeneratorDataKey}
   */
  static randomFinger() {
    return LetterGenerator.randomItemFromArray(LetterGenerator.activeFingers);
  }

  /**
   * @private
   * @returns {{finger: LetterGeneratorDataKey, letter: string}}
   */
  static randomLetter() {
    const finger = LetterGenerator.randomFinger();
    const letter = LetterGenerator.randomItemFromArray(LetterGenerator.data[finger]);
    return { finger, letter };
  }
}

class NumericalSetting {
  /**
   * @private
   * @typedef {(keyof NumericalSetting.data)} NumericalSettingDataKey
   */
  static data = {
    "letter-div-height": 100,
    "letter-speed": 100,
    kpm: 100,
  };

  /**
   * @private
   * @type {{[key in NumericalSettingDataKey]: {step: number, min: number, max: number}}}
   */
  static dataSetting = Object.freeze({
    "letter-div-height": { step: 50, min: 50, max: 300 },
    "letter-speed": { step: 50, min: 50, max: 300 },
    kpm: { step: 5, min: 1, max: 1000 },
  });

  /**
   * @private
   * @type {{[key in NumericalSettingDataKey]: JQuery<HTMLElement>}}
   */
  // @ts-ignore
  static $inputs = {};

  constructor() {
    const setData = this.setData.bind(this);
    const handlePlusBtnClick = this.handlePlusBtnClick.bind(this);
    const handleMinusBtnClick = this.handleMinusBtnClick.bind(this);
    const getInputValue = this.getInputValue.bind(this);

    for (let dataKey in NumericalSetting.data) {
      /** @type {(NumericalSettingDataKey)}*/
      const typedDataKey = /** @type {NumericalSettingDataKey} */ (/** @type {unknown} */ (dataKey));
      const $container = $(`.numerical-setting-container[data-binding=${dataKey}]`);
      $container.find("button[action=increase]").on("click", function () {
        handlePlusBtnClick(typedDataKey);
      });
      $container.find("button[action=decrease]").on("click", function () {
        handleMinusBtnClick(typedDataKey);
      });

      NumericalSetting.$inputs[dataKey] = $container.find("input");
      NumericalSetting.$inputs[dataKey].val(NumericalSetting.data[dataKey].toString());

      const { step, min, max } = NumericalSetting.dataSetting[dataKey];
      NumericalSetting.$inputs[dataKey].attr("min", min.toString());
      NumericalSetting.$inputs[dataKey].attr("max", max.toString());
      NumericalSetting.$inputs[dataKey].attr("step", step.toString());
      NumericalSetting.$inputs[dataKey].on("change", function () {
        const inputValue = NumericalSetting.$inputs[dataKey].val();
        const newNumber = getInputValue(inputValue);
        setData(typedDataKey, newNumber);
      });
    }
  }

  /**
   * @public
   * @param {(NumericalSettingDataKey)} dataKey
   * @return {number}
   */
  getData(dataKey) {
    return NumericalSetting.data[dataKey];
  }

  /**
   * @public
   * @param {(NumericalSettingDataKey)} dataKey
   * @param {number} newNumber
   * @return {void}
   */
  setData(dataKey, newNumber) {
    NumericalSetting.data[dataKey] = this.validateMinMax(dataKey, newNumber);
    NumericalSetting.$inputs[dataKey].val(NumericalSetting.data[dataKey].toString());

    if (dataKey === "letter-div-height") {
      this.letterDivHeightSizeEffect();
    }
  }

  /**
   * @public
   * @param {NumericalSettingDataKey[]} dataKeys
   * @return {void}
   */
  enableInputs(dataKeys) {
    for (let dataKey of dataKeys) {
      NumericalSetting.$inputs[dataKey].prop("disabled", false);
      $(`.numerical-setting-container[data-binding=${dataKey}] button`).prop("disabled", false);
    }
  }

  /**
   * @public
   * @param {NumericalSettingDataKey[]} dataKeys
   * @return {void}
   */
  disableInputs(dataKeys) {
    for (let dataKey of dataKeys) {
      NumericalSetting.$inputs[dataKey].prop("disabled", true);
      $(`.numerical-setting-container[data-binding=${dataKey}] button`).prop("disabled", true);
    }
  }

  /**
   * @private
   * @return {void}
   */
  letterDivHeightSizeEffect() {
    $("#finish-line").css("height", `${NumericalSetting.data["letter-div-height"]}px`);
  }

  /**
   * @private
   * @param {any} inputValue
   * @return {number}
   */
  getInputValue(inputValue) {
    if (typeof inputValue === "number") {
      return inputValue;
    } else if (typeof inputValue === "string") {
      const result = parseInt(inputValue);
      if (isNaN(result)) {
        return 0;
      } else {
        return result;
      }
    }
    return 0;
  }

  /**
   * @private
   * @param {(NumericalSettingDataKey)} dataKey
   * @param {number} newNumber
   * @return {number}
   */
  validateMinMax(dataKey, newNumber) {
    const { min, max } = NumericalSetting.dataSetting[dataKey];
    if (newNumber < min) {
      return min;
    } else if (newNumber > max) {
      return max;
    } else {
      return newNumber;
    }
  }

  /**
   * @private
   * @param {(NumericalSettingDataKey)} dataKey
   * @return {void}
   */
  handlePlusBtnClick(dataKey) {
    const newNumber = NumericalSetting.data[dataKey] + NumericalSetting.dataSetting[dataKey].step;
    this.setData(dataKey, newNumber);
  }

  /**
   * @private
   * @param {(NumericalSettingDataKey)} dataKey
   * @return {void}
   */
  handleMinusBtnClick(dataKey) {
    const newNumber = NumericalSetting.data[dataKey] - NumericalSetting.dataSetting[dataKey].step;
    this.setData(dataKey, newNumber);
  }
}

class StatisticsTable {
  /**
   * @private
   * @typedef {(keyof StatisticsTable.data)} StatisticsTableDataKey
   */
  static data = {
    "perfect-count": 0,
    "good-count": 0,
    "miss-count": 0,
    "combo-count": 0,
    "max-combo-count": 0,
  };

  /**
   * @type {{[key in StatisticsTableDataKey]: JQuery<HTMLElement>}}
   */
  // @ts-ignore
  static $tableCell = {};

  constructor() {
    for (let dataKey in StatisticsTable.data) {
      /** @type {(StatisticsTableDataKey)}*/
      const typedDataKey = /** @type {StatisticsTableDataKey} */ (/** @type {unknown} */ (dataKey));
      StatisticsTable.$tableCell[typedDataKey] = $(`#game-statistics-container table tbody tr td[data-binding=${dataKey}]`);
      StatisticsTable.$tableCell[typedDataKey].text(StatisticsTable.data[dataKey].toString());
    }
  }

  /**
   * @public
   * @param {(StatisticsTableDataKey)} dataKey
   */
  getData(dataKey) {
    return StatisticsTable.data[dataKey];
  }

  /**
   * @public
   * @param {StatisticsTableDataKey} dataKey
   * @return {void}
   */
  addData(dataKey) {
    const newNumber = StatisticsTable.data[dataKey] + 1;
    this.setData(dataKey, newNumber);
  }

  /**
   * @public
   * @param {StatisticsTableDataKey} dataKey
   * @return {void}
   */
  resetData(dataKey) {
    this.setData(dataKey, 0);
  }

  /**
   * @private
   * @return {void}
   */
  sideEffectForSettingCombo() {
    if (StatisticsTable.data["combo-count"] > StatisticsTable.data["max-combo-count"]) {
      this.setData("max-combo-count", StatisticsTable.data["combo-count"]);
    }
  }

  /**
   * @private
   * @param {StatisticsTableDataKey} dataKey
   * @param {number} newNumber
   * @return {void}
   */
  setData(dataKey, newNumber) {
    StatisticsTable.data[dataKey] = newNumber;
    StatisticsTable.$tableCell[dataKey].text(StatisticsTable.data[dataKey].toString());

    if (dataKey === "combo-count") {
      this.sideEffectForSettingCombo();
    }
  }
}

class CharacterSet {
  /**
   * @private
   * @typedef {(keyof CharacterSet.setting)} CharacterSetSettingKey
   */
  static setting = {
    symbol: true,
    digit: true,
    ALPHABET: true,
    alphabet: true,
  };

  /** @type {{[key in CharacterSetSettingKey]: JQuery<HTMLElement>}} */
  // @ts-ignore
  static $switches = {};

  /**
   * @private
   * @type {LetterGenerator}
   */
  letterGenerator;

  /**
   * @param {LetterGenerator} letterGenerator
   */
  constructor(letterGenerator) {
    this.letterGenerator = letterGenerator;

    const toggleSetting = this.toggleSetting.bind(this);

    for (let dataKey in CharacterSet.setting) {
      /** @type {(CharacterSetSettingKey)}*/
      const typedDataKey = /** @type {CharacterSetSettingKey} */ (/** @type {unknown} */ (dataKey));
      CharacterSet.$switches[typedDataKey] = $(`#character-setting-table tr[data-binding=${typedDataKey}] input`);
      CharacterSet.$switches[typedDataKey].prop("checked", CharacterSet.setting[typedDataKey]);
      CharacterSet.$switches[typedDataKey].on("change", function () {
        toggleSetting(typedDataKey);
      });
    }
  }

  /**
   * @public
   * @param {CharacterSetSettingKey} dataKey
   * @return {boolean}
   */
  getSetting(dataKey) {
    return CharacterSet.setting[dataKey];
  }

  /**
   * @private
   * @param {CharacterSetSettingKey} dataKey
   * @param {boolean} checked
   * @return {void}
   */
  setSetting(dataKey, checked) {
    CharacterSet.setting[dataKey] = checked;
    CharacterSet.$switches[dataKey].prop("checked", checked);

    /** @type {Record<string, boolean>} */
    const newAvailableCharacters = {};
    for (let key in KeyData.data) {
      if (CharacterSet.setting[KeyData.data[key].type]) {
        newAvailableCharacters[key] = true;
      } else {
        newAvailableCharacters[key] = false;
      }
    }

    this.letterGenerator.updateData(newAvailableCharacters);
  }

  /**
   * @private
   * @param {CharacterSetSettingKey} dataKey
   * @return {void}
   */
  toggleSetting(dataKey) {
    this.setSetting(dataKey, !CharacterSet.setting[dataKey]);
  }
}

class Game {
  /** @private @type {NumericalSetting} */ numericalSetting;
  /** @private @type {StatisticsTable} */ statisticsTable;
  /** @private @type {LetterGenerator} */ letterGenerator;

  /** @private @type {number}*/ static intervalId = 0;
  /** @private @type {number}*/ static letterIdx = 0;
  /** @private @type {number}*/ static levelCombo = 0;
  /** @private @type {number}*/ static levelComboStep = 5;
  /** @private @type {number}*/ static levelMissing = 0;
  /** @private @type {number}*/ static levelMissingStep = 5;
  /** @private @type {string}*/ static shiftKeyIsPressing = "";

  /**
   * @private
   * @typedef {(keyof Game.switchSetting)} GameSwitchSettingKey
   */
  static switchSetting = {
    "check-left-right-shift": true,
  };

  /** @type {JQuery<HTMLElement>}} */
  // @ts-ignore
  static $comboProgressBar = null;

  /** @type {JQuery<HTMLElement>}} */
  // @ts-ignore
  static $missingProgressBar = null;

  // @ts-ignore
  /** @type {{[key in CharacterSetSettingKey]: JQuery<HTMLElement>}} */ static $switches = {};

  /**
   * @param {NumericalSetting} numericalSetting
   * @param {StatisticsTable} statisticsTable
   * @param {LetterGenerator} letterGenerator
   */
  constructor(numericalSetting, statisticsTable, letterGenerator) {
    this.numericalSetting = numericalSetting;
    this.statisticsTable = statisticsTable;
    this.letterGenerator = letterGenerator;

    const toggleSetting = this.toggleSetting.bind(this);

    for (let dataKey in Game.switchSetting) {
      /** @type {(GameSwitchSettingKey)}*/
      const typedDataKey = /** @type {GameSwitchSettingKey} */ (/** @type {unknown} */ (dataKey));
      Game.$switches[typedDataKey] = $(`div[data-binding=${typedDataKey}] input`);
      Game.$switches[typedDataKey].prop("checked", Game.switchSetting[typedDataKey]);
      Game.$switches[typedDataKey].on("change", function () {
        toggleSetting(typedDataKey);
      });
    }
    Game.$comboProgressBar = $("#combo-progress-bar");
    Game.$missingProgressBar = $("#missing-progress-bar");
  }

  /**
   * @public
   */
  static getIntervalId() {
    return Game.intervalId;
  }

  /**
   * @public
   */
  startPractice(attachListener = true) {
    const increaseLevelMissing = this.increaseLevelMissing.bind(this);
    const resetLevelCombo = this.resetLevelCombo.bind(this);
    const resetLevelMissing = this.resetLevelMissing.bind(this);
    const restartPracticeWithDifferentKmp = this.restartPracticeWithDifferentKmp.bind(this);
    const statisticsTable = this.statisticsTable;

    const trackMap = {
      leftLittle: $("#left-little-track"),
      leftRing: $("#left-ring-track"),
      leftMiddle: $("#left-middle-track"),
      leftIndex: $("#left-index-track"),
      rightIndex: $("#right-index-track"),
      rightMiddle: $("#right-middle-track"),
      rightRing: $("#right-ring-track"),
      rightLittle: $("#right-little-track"),
    };
    const trackHeight = $("#track-container").height() ?? 0;

    const kpm = this.numericalSetting.getData("kpm");
    const letterSpeed = this.numericalSetting.getData("letter-speed");
    const letterDivHeight = this.numericalSetting.getData("letter-div-height");

    const timeInterval = (1 / (kpm / 60)) * 1000;
    /**@type {[number, number]} */
    const perfectRange = [trackHeight - 2 * letterDivHeight, trackHeight - letterDivHeight];

    Game.intervalId = window.setInterval(() => {
      const newLetter = this.generateNewLetterElement(letterDivHeight, Game.letterIdx++);

      if (newLetter) {
        const { finger, element } = newLetter;
        $(trackMap[finger]).append(element);
        $(element).animate({ top: trackHeight + letterDivHeight }, ((trackHeight + letterDivHeight) / letterSpeed) * 1000, "linear", function () {
          statisticsTable.addData("miss-count");
          statisticsTable.resetData("combo-count");
          increaseLevelMissing();
          $(element).remove();
        });
      }

      if (Game.levelCombo >= Game.levelComboStep) {
        resetLevelCombo();
        resetLevelMissing();
        restartPracticeWithDifferentKmp(kpm + 1);
      }

      if (Game.levelMissing >= Game.levelMissingStep) {
        resetLevelCombo();
        resetLevelMissing();
        restartPracticeWithDifferentKmp(kpm - 1);
      }
    }, timeInterval);

    if (attachListener) {
      this.attachKeydownKeyupListener(trackMap, perfectRange);
    }

    this.toggleInputAndButtonWhenStartOrStop("start");
  }

  /**
   * @public
   */
  stopPractice() {
    this.clearInterval();
    $(document).off("keydown.game");
    $(document).off("keyup.game");
    $(".letter").stop().remove();
    this.toggleInputAndButtonWhenStartOrStop("stop");
  }

  /**
   * @private
   * @param {GameSwitchSettingKey} dataKey
   */
  getSwitchSetting(dataKey) {
    return Game.switchSetting[dataKey];
  }

  /**
   * @private
   * @param {GameSwitchSettingKey} dataKey
   * @param {boolean} checked
   */
  setSwitchSetting(dataKey, checked) {
    Game.switchSetting[dataKey] = checked;
    Game.$switches[dataKey].prop("checked", checked);
  }

  /**
   * @private
   * @param {GameSwitchSettingKey} dataKey
   */
  toggleSetting(dataKey) {
    this.setSwitchSetting(dataKey, !Game.switchSetting[dataKey]);
  }

  /**
   * @private
   * @param {string} type
   */
  toggleInputAndButtonWhenStartOrStop(type) {
    const bool = type === "start" ? true : false;

    bool ? this.numericalSetting.disableInputs(["kpm", "letter-speed", "letter-div-height"]) : this.numericalSetting.enableInputs(["kpm", "letter-speed", "letter-div-height"]);
    $("#check-left-right-shift-setting-container input").prop("disabled", bool);
    $("#start-practice-btn").prop("disabled", bool);
    $("#stop-practice-btn").prop("disabled", !bool);
  }

  /**
   * @private
   * @param {{[key in LetterGeneratorDataKey]: JQuery<HTMLElement>}} trackMap
   * @param {[number, number]} perfectRange
   */
  attachKeydownKeyupListener(trackMap, perfectRange) {
    const increaseLevelCombo = this.increaseLevelCombo.bind(this);
    const statisticsTable = this.statisticsTable;

    const checkLeftRightShift = this.getSwitchSetting("check-left-right-shift");

    $(document).on("keydown.game", function (/** @type{JQuery.KeyDownEvent<Document, undefined, Document, Document>}*/ e) {
      if (e.code === "ShiftLeft" && Game.shiftKeyIsPressing !== "left") {
        Game.shiftKeyIsPressing = "left";
      } else if (e.code === "ShiftRight" && Game.shiftKeyIsPressing !== "right") {
        Game.shiftKeyIsPressing = "right";
      }
    });

    $(document).on("keyup.game", function (/** @type{JQuery.KeyUpEvent<Document, undefined, Document, Document>} */ e) {
      if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
        Game.shiftKeyIsPressing = "";
        return;
      }

      const finger = KeyData.getFinger(e.key);
      if (finger) {
        const track = trackMap[finger];
        const firstChild = $(track).children().first();
        if (e.key === $(firstChild).text()) {
          if (checkLeftRightShift) {
            if (KeyData.data[e.key].shiftFinger !== Game.shiftKeyIsPressing) {
              return;
            }
          }

          const top = parseInt($(firstChild).css("top").replace("px", ""));
          if (top >= perfectRange[0] && top <= perfectRange[1]) {
            statisticsTable.addData("perfect-count");
            statisticsTable.addData("combo-count");
            $(firstChild).stop().remove();
            increaseLevelCombo(2);
          } else {
            statisticsTable.addData("good-count");
            statisticsTable.addData("combo-count");
            $(firstChild).stop().remove();
            increaseLevelCombo(1);
          }
        }
      }
    });
  }

  /**
   * @private
   */
  clearInterval() {
    window.clearInterval(Game.getIntervalId());
    Game.intervalId = 0;
  }

  /**
   * @private
   * @param {number} kpm
   */
  restartPracticeWithDifferentKmp(kpm) {
    this.clearInterval();
    this.numericalSetting.setData("kpm", kpm);
    this.startPractice(false);
  }

  /**
   * @private
   * @param {number} newValue
   */
  setLevelCombo(newValue) {
    Game.levelCombo = newValue;
    Game.$comboProgressBar.css("width", `${(Game.levelCombo / Game.levelComboStep) * 100}%`);
  }

  /**
   * @private
   * @param {number} increment
   */
  increaseLevelCombo(increment) {
    this.setLevelCombo(Game.levelCombo + increment);
    this.resetLevelMissing();
  }

  // /**
  //  * @private
  //  * @param {number} decrement
  //  */
  // static decreaseLevelCombo(decrement) {
  //   Game.setLevelCombo(Game.levelCombo - decrement);
  // }

  /**
   * @private
   */
  resetLevelCombo() {
    this.setLevelCombo(0);
  }

  /**
   * @private
   * @param {number} newValue
   */
  setLevelMissing(newValue) {
    Game.levelMissing = newValue;
    Game.$missingProgressBar.css("width", `${(Game.levelMissing / Game.levelMissingStep) * 100}%`);
  }

  /**
   * @private
   */
  increaseLevelMissing() {
    this.setLevelMissing(Game.levelMissing + 1);
    this.resetLevelCombo();
  }

  /**
   * @private
   */
  resetLevelMissing() {
    this.setLevelMissing(0);
  }

  /**
   * @private
   * @param {number} idx
   */
  getZIndex(idx) {
    return 1000 - (idx % 1000);
  }

  /**
   * @private
   * @param {number} letterDivHeight
   * @param {number} idx
   * @returns {{finger: LetterGeneratorDataKey, element: JQuery<HTMLElement>} | undefined}
   */
  generateNewLetterElement(letterDivHeight, idx) {
    const getZIndex = this.getZIndex.bind(this);

    const letterDivHeightStr = letterDivHeight.toString() + "px";
    const { finger, letter } = this.letterGenerator.generateRandomLetter(1)[0];

    if (!letter) {
      return undefined;
    }

    let element = $("<div class='letter'></div>")
      .css({ height: letterDivHeightStr, top: "-" + letterDivHeightStr, zIndex: getZIndex(idx) })
      .text(letter);

    return { finger, element };
  }
}

// $(document).ready
$(function () {
  // let intervalId = 0;

  const letterGenerator = new LetterGenerator();
  const characterSet = new CharacterSet(letterGenerator);
  const statisticsTable = new StatisticsTable();
  const numericalSetting = new NumericalSetting();
  const game = new Game(numericalSetting, statisticsTable, letterGenerator);

  $("#start-practice-btn").on("click", function () {
    if (Game.getIntervalId() === 0) {
      game.startPractice();
    }
  });

  $("#stop-practice-btn").on("click", function () {
    if (Game.getIntervalId() !== 0) {
      game.stopPractice();
    }
  });
});

// #region for debugging

// let debugData = {};

// const lettersForEachFingerDebug = Object.freeze({
//     leftLittle: ["1", "q", "a", "z", "!", "Q", "A", "Z"],
//     leftRing: ["2", "w", "s", "x", "@", "W", "S", "X"],
//     leftMiddle: ["3", "e", "d", "c", "#", "E", "D", "C"],
//     leftIndex: ["4", "r", "f", "v", "5", "t", "g", "b", "$", "R", "F", "V", "%", "T", "G", "B"],
//     rightIndex: ["6", "y", "h", "n", "7", "u", "j", "m", "^", "Y", "H", "N", "&", "U", "J", "M"],
//     rightMiddle: ["8", "i", "k", ",", "*", "I", "K", "<"],
//     rightRing: ["9", "o", "l", ".", "(", "O", "L", ">"],
//     rightLittle: ["0", "p", ";", "/", ")", "P", ":", "?"],
// });

// /**
//  *
//  * @param {string} key
//  * @returns {string}
//  */
// function generateFinger(key) {
//     const finger = Object.keys(lettersForEachFingerDebug).find((finger) =>
//         lettersForEachFingerDebug[finger].includes(key)
//     );
//     return finger ?? "no-data";
// }

// $(document).on("keyup", function (e) {
//     console.log(e.key);
//     console.log(e);
//     const obj = {
//         key: e.key,
//         code: e.code,
//         shiftKey: e.shiftKey,
//         finger: generateFinger(e.key),
//         shiftFinger: e.shiftKey ? (generateFinger(e.key).includes("left") ? "left" : "right") : "",
//     };
//     debugData[e.key] = obj;
// });

// let all = Object.values(KeyData.data);
// console.log(`all.length`, all.length);

// let alphabet = [];
// let ALPHABET = [];
// let digit = [];
// let symbol = [];

// for (let x of all) {
//     if (x.key.match(/[a-z]/)) {
//         alphabet.push(x);
//     } else if (x.key.match(/[A-Z]/)) {
//         ALPHABET.push(x);
//     } else if (x.key.match(/[0-9]/)) {
//         digit.push(x);
//     } else {
//         symbol.push(x);
//     }
// }

// console.log(`alphabet`, alphabet);
// console.log(`ALPHABET`, ALPHABET);
// console.log(`digit`, digit);
// console.log(`symbol`, symbol);

// console.log(`alphabet.length`, alphabet.length);
// console.log(`ALPHABET.length`, ALPHABET.length);
// console.log(`digit.length`, digit.length);
// console.log(`symbol.length`, symbol.length);
// console.log(`sum of length`, alphabet.length + ALPHABET.length + digit.length + symbol.length);

// function checkDigits() {
//     const digits = [];

//     for (let myKey in KeyData.data) {
//         if (KeyData.data[myKey].type === "digit") {
//             digits.push(KeyData.data[myKey]);
//         }
//     }

//     digits.sort((a, b) => parseInt(a.key) - parseInt(b.key));
//     console.log(
//         `checkDigits ~ digits.key`,
//         digits.map((x) => x.key)
//     );
//     console.log("check length", digits.length === 10);
//     console.log(
//         "check shift",
//         digits.every((x) => x.shiftKey === false && x.shiftFinger === "")
//     );
// }
// checkDigits();

// function checkAlphabet() {
//     const alphabet = [];

//     for (let myKey in KeyData.data) {
//         if (KeyData.data[myKey].type === "alphabet") {
//             alphabet.push(KeyData.data[myKey]);
//         }
//     }

//     alphabet.sort((a, b) => a.key.localeCompare(b.key));
//     console.log(
//         `checkAlphabet ~ alphabet.key`,
//         alphabet.map((x) => x.key)
//     );
//     console.log("check length", alphabet.length === 26);
//     console.log(
//         "check shift",
//         alphabet.every((x) => x.shiftKey === false && x.shiftFinger === "")
//     );
// }
// checkAlphabet();

// function checkALPHABET() {
//     const ALPHABET = [];

//     for (let myKey in KeyData.data) {
//         if (KeyData.data[myKey].type === "ALPHABET") {
//             ALPHABET.push(KeyData.data[myKey]);
//         }
//     }

//     ALPHABET.sort((a, b) => a.key.localeCompare(b.key));
//     console.log(
//         `checkALPHABET ~ ALPHABET.key`,
//         ALPHABET.map((x) => x.key)
//     );
//     console.log("check length", ALPHABET.length === 26);
//     console.log(
//         "check shift",
//         ALPHABET.every((x) => (x.shiftKey === true && x.shiftFinger === "left") || "right")
//     );
// }
// checkALPHABET();

// #endregion

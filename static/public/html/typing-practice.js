//@ts-check

class KeyData {
  static data = Object.freeze({
    0: {
      key: "0",
      code: "Digit0",
      shiftKey: false,
      finger: "rightLittle",
      shiftFinger: "",
      type: "digit",
    },
    1: {
      key: "1",
      code: "Digit1",
      shiftKey: false,
      finger: "leftLittle",
      shiftFinger: "",
      type: "digit",
    },
    2: {
      key: "2",
      code: "Digit2",
      shiftKey: false,
      finger: "leftRing",
      shiftFinger: "",
      type: "digit",
    },
    3: {
      key: "3",
      code: "Digit3",
      shiftKey: false,
      finger: "leftMiddle",
      shiftFinger: "",
      type: "digit",
    },
    4: {
      key: "4",
      code: "Digit4",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "digit",
    },
    5: {
      key: "5",
      code: "Digit5",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "digit",
    },
    6: {
      key: "6",
      code: "Digit6",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "digit",
    },
    7: {
      key: "7",
      code: "Digit7",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "digit",
    },
    8: {
      key: "8",
      code: "Digit8",
      shiftKey: false,
      finger: "rightMiddle",
      shiftFinger: "",
      type: "digit",
    },
    9: {
      key: "9",
      code: "Digit9",
      shiftKey: false,
      finger: "rightRing",
      shiftFinger: "",
      type: "digit",
    },
    q: {
      key: "q",
      code: "KeyQ",
      shiftKey: false,
      finger: "leftLittle",
      shiftFinger: "",
      type: "alphabet",
    },
    a: {
      key: "a",
      code: "KeyA",
      shiftKey: false,
      finger: "leftLittle",
      shiftFinger: "",
      type: "alphabet",
    },
    z: {
      key: "z",
      code: "KeyZ",
      shiftKey: false,
      finger: "leftLittle",
      shiftFinger: "",
      type: "alphabet",
    },
    w: {
      key: "w",
      code: "KeyW",
      shiftKey: false,
      finger: "leftRing",
      shiftFinger: "",
      type: "alphabet",
    },
    s: {
      key: "s",
      code: "KeyS",
      shiftKey: false,
      finger: "leftRing",
      shiftFinger: "",
      type: "alphabet",
    },
    x: {
      key: "x",
      code: "KeyX",
      shiftKey: false,
      finger: "leftRing",
      shiftFinger: "",
      type: "alphabet",
    },
    e: {
      key: "e",
      code: "KeyE",
      shiftKey: false,
      finger: "leftMiddle",
      shiftFinger: "",
      type: "alphabet",
    },
    d: {
      key: "d",
      code: "KeyD",
      shiftKey: false,
      finger: "leftMiddle",
      shiftFinger: "",
      type: "alphabet",
    },
    c: {
      key: "c",
      code: "KeyC",
      shiftKey: false,
      finger: "leftMiddle",
      shiftFinger: "",
      type: "alphabet",
    },
    r: {
      key: "r",
      code: "KeyR",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    f: {
      key: "f",
      code: "KeyF",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    v: {
      key: "v",
      code: "KeyV",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    t: {
      key: "t",
      code: "KeyT",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    g: {
      key: "g",
      code: "KeyG",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    b: {
      key: "b",
      code: "KeyB",
      shiftKey: false,
      finger: "leftIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    y: {
      key: "y",
      code: "KeyY",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    h: {
      key: "h",
      code: "KeyH",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    n: {
      key: "n",
      code: "KeyN",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    u: {
      key: "u",
      code: "KeyU",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    j: {
      key: "j",
      code: "KeyJ",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    m: {
      key: "m",
      code: "KeyM",
      shiftKey: false,
      finger: "rightIndex",
      shiftFinger: "",
      type: "alphabet",
    },
    i: {
      key: "i",
      code: "KeyI",
      shiftKey: false,
      finger: "rightMiddle",
      shiftFinger: "",
      type: "alphabet",
    },
    k: {
      key: "k",
      code: "KeyK",
      shiftKey: false,
      finger: "rightMiddle",
      shiftFinger: "",
      type: "alphabet",
    },
    ",": {
      key: ",",
      code: "Comma",
      shiftKey: false,
      finger: "rightMiddle",
      shiftFinger: "",
      type: "punctuation",
    },
    o: {
      key: "o",
      code: "KeyO",
      shiftKey: false,
      finger: "rightRing",
      shiftFinger: "",
      type: "alphabet",
    },
    l: {
      key: "l",
      code: "KeyL",
      shiftKey: false,
      finger: "rightRing",
      shiftFinger: "",
      type: "alphabet",
    },
    ".": {
      key: ".",
      code: "Period",
      shiftKey: false,
      finger: "rightRing",
      shiftFinger: "",
      type: "punctuation",
    },
    p: {
      key: "p",
      code: "KeyP",
      shiftKey: false,
      finger: "rightLittle",
      shiftFinger: "",
      type: "alphabet",
    },
    ";": {
      key: ";",
      code: "Semicolon",
      shiftKey: false,
      finger: "rightLittle",
      shiftFinger: "",
      type: "punctuation",
    },
    "/": {
      key: "/",
      code: "Slash",
      shiftKey: false,
      finger: "rightLittle",
      shiftFinger: "",
      type: "punctuation",
    },
    "!": {
      key: "!",
      code: "Digit1",
      shiftKey: true,
      finger: "leftLittle",
      shiftFinger: "right",
      type: "punctuation",
    },
    Q: {
      key: "Q",
      code: "KeyQ",
      shiftKey: true,
      finger: "leftLittle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    A: {
      key: "A",
      code: "KeyA",
      shiftKey: true,
      finger: "leftLittle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    Z: {
      key: "Z",
      code: "KeyZ",
      shiftKey: true,
      finger: "leftLittle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    "@": {
      key: "@",
      code: "Digit2",
      shiftKey: true,
      finger: "leftRing",
      shiftFinger: "right",
      type: "punctuation",
    },
    W: {
      key: "W",
      code: "KeyW",
      shiftKey: true,
      finger: "leftRing",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    S: {
      key: "S",
      code: "KeyS",
      shiftKey: true,
      finger: "leftRing",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    X: {
      key: "X",
      code: "KeyX",
      shiftKey: true,
      finger: "leftRing",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    "#": {
      key: "#",
      code: "Digit3",
      shiftKey: true,
      finger: "leftMiddle",
      shiftFinger: "right",
      type: "punctuation",
    },
    E: {
      key: "E",
      code: "KeyE",
      shiftKey: true,
      finger: "leftMiddle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    D: {
      key: "D",
      code: "KeyD",
      shiftKey: true,
      finger: "leftMiddle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    C: {
      key: "C",
      code: "KeyC",
      shiftKey: true,
      finger: "leftMiddle",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    $: {
      key: "$",
      code: "Digit4",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "punctuation",
    },
    R: {
      key: "R",
      code: "KeyR",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    F: {
      key: "F",
      code: "KeyF",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    V: {
      key: "V",
      code: "KeyV",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    "%": {
      key: "%",
      code: "Digit5",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "punctuation",
    },
    T: {
      key: "T",
      code: "KeyT",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    G: {
      key: "G",
      code: "KeyG",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    B: {
      key: "B",
      code: "KeyB",
      shiftKey: true,
      finger: "leftIndex",
      shiftFinger: "right",
      type: "ALPHABET",
    },
    "^": {
      key: "^",
      code: "Digit6",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "punctuation",
    },
    Y: {
      key: "Y",
      code: "KeyY",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    H: {
      key: "H",
      code: "KeyH",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    N: {
      key: "N",
      code: "KeyN",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    "&": {
      key: "&",
      code: "Digit7",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "punctuation",
    },
    U: {
      key: "U",
      code: "KeyU",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    J: {
      key: "J",
      code: "KeyJ",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    M: {
      key: "M",
      code: "KeyM",
      shiftKey: true,
      finger: "rightIndex",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    "*": {
      key: "*",
      code: "Digit8",
      shiftKey: true,
      finger: "rightMiddle",
      shiftFinger: "left",
      type: "punctuation",
    },
    I: {
      key: "I",
      code: "KeyI",
      shiftKey: true,
      finger: "rightMiddle",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    K: {
      key: "K",
      code: "KeyK",
      shiftKey: true,
      finger: "rightMiddle",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    "<": {
      key: "<",
      code: "Comma",
      shiftKey: true,
      finger: "rightMiddle",
      shiftFinger: "left",
      type: "punctuation",
    },
    "(": {
      key: "(",
      code: "Digit9",
      shiftKey: true,
      finger: "rightRing",
      shiftFinger: "left",
      type: "punctuation",
    },
    O: {
      key: "O",
      code: "KeyO",
      shiftKey: true,
      finger: "rightRing",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    L: {
      key: "L",
      code: "KeyL",
      shiftKey: true,
      finger: "rightRing",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    ">": {
      key: ">",
      code: "Period",
      shiftKey: true,
      finger: "rightRing",
      shiftFinger: "left",
      type: "punctuation",
    },
    ")": {
      key: ")",
      code: "Digit0",
      shiftKey: true,
      finger: "rightLittle",
      shiftFinger: "left",
      type: "punctuation",
    },
    P: {
      key: "P",
      code: "KeyP",
      shiftKey: true,
      finger: "rightLittle",
      shiftFinger: "left",
      type: "ALPHABET",
    },
    ":": {
      key: ":",
      code: "Semicolon",
      shiftKey: true,
      finger: "rightLittle",
      shiftFinger: "left",
      type: "punctuation",
    },
    "?": {
      key: "?",
      code: "Slash",
      shiftKey: true,
      finger: "rightLittle",
      shiftFinger: "left",
      type: "punctuation",
    },
  });

  constructor() {}

  /**
   *
   * @param {string} key
   * @returns {string}
   */
  static getFinger(key) {
    return KeyData.data[key]?.finger ?? "";
  }
}

class NumericalSetting {
  /**
   * @private
   * @typedef {(keyof NumericalSetting.data)} NumericalSettingDataKey
   */
  static data = {
    "letter-div-height": 100,
    "letter-speed": 100,
    kpm: 100,
  };

  /**
   * @private
   * @type {{[key in NumericalSettingDataKey]: {step: number, min: number, max: number}}}
   */
  static dataSetting = Object.freeze({
    "letter-div-height": { step: 50, min: 50, max: 300 },
    "letter-speed": { step: 50, min: 50, max: 300 },
    kpm: { step: 5, min: 1, max: 1000 },
  });

  /**
   * @private
   * @type {{[key in NumericalSettingDataKey]: JQuery<HTMLElement>}}
   */
  // @ts-ignore
  static $inputs = {};

  constructor() {}

  /** @public */
  static initializeClass() {
    for (let dataKey in NumericalSetting.data) {
      /** @type {(NumericalSettingDataKey)}*/
      const typedDataKey = /** @type {NumericalSettingDataKey} */ (/** @type {unknown} */ (dataKey));
      const $container = $(`.numerical-setting-container[data-binding=${dataKey}]`);
      $container.find("button[action=increase]").on("click", function () {
        NumericalSetting.increaseData(typedDataKey);
      });
      $container.find("button[action=decrease]").on("click", function () {
        NumericalSetting.decreaseData(typedDataKey);
      });

      NumericalSetting.$inputs[dataKey] = $container.find("input");
      NumericalSetting.$inputs[dataKey].val(NumericalSetting.data[dataKey].toString());

      const { step, min, max } = NumericalSetting.dataSetting[dataKey];
      NumericalSetting.$inputs[dataKey].attr("min", min.toString());
      NumericalSetting.$inputs[dataKey].attr("max", max.toString());
      NumericalSetting.$inputs[dataKey].attr("step", step.toString());

      NumericalSetting.$inputs[dataKey].on("change", function () {
        const inputValue = NumericalSetting.$inputs[dataKey].val();
        const newNumber = typeof inputValue === "number" ? inputValue : typeof inputValue === "string" ? parseInt(inputValue) : 0;
        NumericalSetting.setData(typedDataKey, newNumber);
      });
    }
  }

  /**
   * @public
   * @param {(NumericalSettingDataKey)} dataKey
   * @return {number}
   */
  static getData(dataKey) {
    return NumericalSetting.data[dataKey];
  }

  /**
   * @public
   * @param {NumericalSettingDataKey[]} dataKeys
   */
  static disableInputs(dataKeys) {
    for (let dataKey of dataKeys) {
      NumericalSetting.$inputs[dataKey].prop("disabled", true);
      $(`.numerical-setting-container[data-binding=${dataKey}] button`).prop("disabled", true);
    }
  }

  /**
   * @public
   * @param {NumericalSettingDataKey[]} dataKeys
   */
  static enableInputs(dataKeys) {
    for (let dataKey of dataKeys) {
      NumericalSetting.$inputs[dataKey].prop("disabled", false);
      $(`.numerical-setting-container[data-binding=${dataKey}] button`).prop("disabled", false);
    }
  }

  /**
   * @private
   */
  static letterDivHeightSizeEffect() {
    $("#finish-line").css("height", `${NumericalSetting.data["letter-div-height"]}px`);
  }

  /**
   * @private
   * @param {(NumericalSettingDataKey)} dataKey
   * @param {number} newNumber
   * @returns {number}
   */
  static validateMinMax(dataKey, newNumber) {
    const { min, max } = NumericalSetting.dataSetting[dataKey];
    if (newNumber < min) {
      return min;
    } else if (newNumber > max) {
      return max;
    } else {
      return newNumber;
    }
  }

  /**
   * @private
   * @param {(NumericalSettingDataKey)} dataKey
   * @param {number} newNumber
   */
  static setData(dataKey, newNumber) {
    NumericalSetting.data[dataKey] = NumericalSetting.validateMinMax(dataKey, newNumber);
    NumericalSetting.$inputs[dataKey].val(NumericalSetting.data[dataKey].toString());

    if (dataKey === "letter-div-height") {
      NumericalSetting.letterDivHeightSizeEffect();
    }
  }

  /**
   * @private
   * @param {(NumericalSettingDataKey)} dataKey
   */
  static increaseData(dataKey) {
    const newNumber = NumericalSetting.data[dataKey] + NumericalSetting.dataSetting[dataKey].step;
    NumericalSetting.setData(dataKey, newNumber);
  }

  /**
   * @private
   * @param {(NumericalSettingDataKey)} dataKey
   */
  static decreaseData(dataKey) {
    const newNumber = NumericalSetting.data[dataKey] - NumericalSetting.dataSetting[dataKey].step;
    NumericalSetting.setData(dataKey, newNumber);
  }
}

class StatisticsTable {
  /**
   * @private
   * @typedef {(keyof StatisticsTable.data)} StatisticsTableDataKey
   */
  static data = {
    "perfect-count": 0,
    "good-count": 0,
    "miss-count": 0,
    "combo-count": 0,
    "max-combo-count": 0,
  };

  /**
   * @type {{[key in StatisticsTableDataKey]: JQuery<HTMLElement>}}
   */
  // @ts-ignore
  static $tableCell = {};

  constructor() {}

  /** @public */
  static initializeClass() {
    for (let dataKey in StatisticsTable.data) {
      /** @type {(StatisticsTableDataKey)}*/
      const typedDataKey = /** @type {StatisticsTableDataKey} */ (/** @type {unknown} */ (dataKey));
      StatisticsTable.$tableCell[typedDataKey] = $(`#game-statistics-container table tbody tr td[data-binding=${dataKey}]`);
      StatisticsTable.$tableCell[typedDataKey].text(StatisticsTable.data[dataKey].toString());
    }
  }

  /**
   * @public
   * @param {StatisticsTableDataKey} dataKey
   */
  static addData(dataKey) {
    const newNumber = StatisticsTable.data[dataKey] + 1;
    StatisticsTable.setData(dataKey, newNumber);
  }

  /**
   * @public
   * @param {StatisticsTableDataKey} dataKey
   */
  static resetData(dataKey) {
    StatisticsTable.setData(dataKey, 0);
  }

  /** @private */
  static sideEffectForSettingCombo() {
    if (StatisticsTable.data["combo-count"] > StatisticsTable.data["max-combo-count"]) {
      StatisticsTable.setData("max-combo-count", StatisticsTable.data["combo-count"]);
    }
  }

  /**
   * @private
   * @param {StatisticsTableDataKey} dataKey
   * @param {number} newNumber
   */
  static setData(dataKey, newNumber) {
    StatisticsTable.data[dataKey] = newNumber;
    StatisticsTable.$tableCell[dataKey].text(StatisticsTable.data[dataKey].toString());

    if (dataKey === "combo-count") {
      StatisticsTable.sideEffectForSettingCombo();
    }
  }
}

class CharacterSet {
  /**
   * @private
   * @typedef {(keyof CharacterSet.setting)} CharacterSetSettingKey
   */
  static setting = {
    punctuation: true,
    digit: true,
    ALPHABET: true,
    alphabet: true,
  };

  /** @type {{[key in CharacterSetSettingKey]: JQuery<HTMLElement>}} */
  // @ts-ignore
  static $switches = {};

  constructor() {}

  /**
   * @public
   */
  static initializeClass() {
    for (let dataKey in CharacterSet.setting) {
      /** @type {(CharacterSetSettingKey)}*/
      const typedDataKey = /** @type {CharacterSetSettingKey} */ (/** @type {unknown} */ (dataKey));
      CharacterSet.$switches[typedDataKey] = $(`#character-setting-table tr[data-binding=${typedDataKey}] input`);
      CharacterSet.$switches[typedDataKey].prop("checked", CharacterSet.setting[typedDataKey]);
      CharacterSet.$switches[typedDataKey].on("change", function () {
        CharacterSet.toggleSetting(typedDataKey);
      });
    }
  }

  /**
   * @public
   * @param {CharacterSetSettingKey} dataKey
   */
  static getSetting(dataKey) {
    return CharacterSet.setting[dataKey];
  }

  /**
   * @private
   * @param {CharacterSetSettingKey} dataKey
   * @param {boolean} checked
   */
  static setSetting(dataKey, checked) {
    CharacterSet.setting[dataKey] = checked;
    CharacterSet.$switches[dataKey].prop("checked", checked);
    LettersForEachFinger.updateLettersForEachFinger();
  }

  /**
   * @private
   * @param {CharacterSetSettingKey} dataKey
   */
  static toggleSetting(dataKey) {
    CharacterSet.setSetting(dataKey, !CharacterSet.setting[dataKey]);
  }
}

class Game {
  /**
   * @private
   * @typedef {(keyof Game.switchSetting)} GameSwitchSettingKey
   */
  static switchSetting = {
    "check-left-right-shift": true,
  };

  /** @type {{[key in CharacterSetSettingKey]: JQuery<HTMLElement>}} */
  // @ts-ignore
  static $switches = {};

  constructor() {}

  /**
   * @public
   */
  static initializeClass() {
    for (let dataKey in Game.switchSetting) {
      /** @type {(GameSwitchSettingKey)}*/
      const typedDataKey = /** @type {GameSwitchSettingKey} */ (/** @type {unknown} */ (dataKey));
      Game.$switches[typedDataKey] = $(`div[data-binding=${typedDataKey}] input`);
      Game.$switches[typedDataKey].prop("checked", Game.switchSetting[typedDataKey]);
      Game.$switches[typedDataKey].on("change", function () {
        Game.toggleSetting(typedDataKey);
      });
    }
  }

  /**
   * @public
   * @param {GameSwitchSettingKey} dataKey
   */
  static getSwitchSetting(dataKey) {
    return Game.switchSetting[dataKey];
  }

  /**
   * @private
   * @param {GameSwitchSettingKey} dataKey
   * @param {boolean} checked
   */
  static setSwitchSetting(dataKey, checked) {
    Game.switchSetting[dataKey] = checked;
    Game.$switches[dataKey].prop("checked", checked);
  }

  /**
   * @private
   * @param {GameSwitchSettingKey} dataKey
   */
  static toggleSetting(dataKey) {
    Game.setSwitchSetting(dataKey, !Game.switchSetting[dataKey]);
  }
}

class LettersForEachFinger {
  /**
   * @private
   * @typedef {(keyof LettersForEachFinger.data)} LettersForEachFingerDataKey
   */
  static data = {
    leftLittle: ["1", "q", "a", "z", "!", "Q", "A", "Z"],
    leftRing: ["2", "w", "s", "x", "@", "W", "S", "X"],
    leftMiddle: ["3", "e", "d", "c", "#", "E", "D", "C"],
    leftIndex: ["4", "r", "f", "v", "5", "t", "g", "b", "$", "R", "F", "V", "%", "T", "G", "B"],
    rightIndex: ["6", "y", "h", "n", "7", "u", "j", "m", "^", "Y", "H", "N", "&", "U", "J", "M"],
    rightMiddle: ["8", "i", "k", ",", "*", "I", "K", "<"],
    rightRing: ["9", "o", "l", ".", "(", "O", "L", ">"],
    rightLittle: ["0", "p", ";", "/", ")", "P", ":", "?"],
  };

  /**
   * @public
   * @typedef {LettersForEachFingerDataKey[]} LettersForEachFingerSettingKey
   */
  static fingers = Object.freeze(["leftLittle", "leftRing", "leftMiddle", "leftIndex", "rightIndex", "rightMiddle", "rightRing", "rightLittle"]);

  constructor() {}

  /**
   * @public
   */
  static getAllDate() {
    return LettersForEachFinger.data;
  }

  /**
   * @public
   * @param {LettersForEachFingerDataKey} dataKey
   */
  static getOneFingerDate(dataKey) {
    return LettersForEachFinger.data[dataKey];
  }

  /**
   * @public
   */
  static updateLettersForEachFinger() {
    for (let key in LettersForEachFinger.data) {
      LettersForEachFinger.data[key] = [];
    }
    for (let key in KeyData.data) {
      const type = KeyData.data[key].type;
      if (CharacterSet.getSetting(type)) {
        const finger = KeyData.data[key].finger;
        LettersForEachFinger.data[finger].push(key);
      }
    }
  }

  /**
   * @private
   * @param {number} min
   * @param {number} max
   * @returns {number}
   */
  static randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  /**
   * @public
   * @returns {LettersForEachFingerDataKey}
   */
  static randomFinger() {
    /** @type {LettersForEachFingerDataKey} */
    const typedFinger = /** @type {LettersForEachFingerDataKey} */ (LettersForEachFinger.fingers[LettersForEachFinger.randomInt(0, 7)]);
    return typedFinger;
  }

  /**
   * @public
   * @param {LettersForEachFingerDataKey} finger
   * @returns {string}
   */
  static randomLetter(finger) {
    const letters = LettersForEachFinger.getOneFingerDate(finger);
    return letters[LettersForEachFinger.randomInt(0, letters.length - 1)];
  }
}

/**
 *
 * @param {number} idx
 */
function getZIndex(idx) {
  return 1000 - (idx % 1000);
}

/**
 *
 * @param {LettersForEachFingerDataKey} finger
 * @param {number} letterDivHeight
 * @param {number} idx
 * @returns {JQuery<HTMLElement>}
 */
function generateNewLetter(finger, letterDivHeight, idx) {
  const letterDivHeightStr = letterDivHeight.toString() + "px";

  let newElement = $("<div class='letter'></div>")
    .css({ height: letterDivHeightStr, top: "-" + letterDivHeightStr, zIndex: getZIndex(idx) })
    .text(LettersForEachFinger.randomLetter(finger));

  return newElement;
}

/**
 *
 * @param {string} type
 */
function toggleSettingWhenStartOrStop(type) {
  const bool = type === "start" ? true : false;

  bool ? NumericalSetting.disableInputs(["kpm", "letter-speed", "letter-div-height"]) : NumericalSetting.enableInputs(["kpm", "letter-speed", "letter-div-height"]);
  $("#check-left-right-shift-setting-container input").prop("disabled", bool);
  $("#start-practice-btn").prop("disabled", bool);
  $("#stop-practice-btn").prop("disabled", !bool);
}

/**
 *
 * @param {number} kpm
 * @param {number} letterSpeed
 * @param {number} letterDivHeight
 * @param {any} trackMap
 * @param {number} trackHeight
 * @param {boolean} checkLeftRightShift
 */
function startPractice(kpm, letterSpeed, letterDivHeight, trackMap, trackHeight, checkLeftRightShift) {
  let idx = 0;
  let shiftKeyIsPressing = "";
  const timeInterval = (1 / (kpm / 60)) * 1000;
  const perfectRange = [trackHeight - 2 * letterDivHeight, trackHeight - letterDivHeight];

  const intervalId = window.setInterval(() => {
    let finger = LettersForEachFinger.randomFinger();
    let newLetter = generateNewLetter(finger, letterDivHeight, idx++);
    $(trackMap[finger]).append(newLetter);
    $(newLetter).animate({ top: trackHeight + letterDivHeight }, ((trackHeight + letterDivHeight) / letterSpeed) * 1000, "linear", function () {
      StatisticsTable.addData("miss-count");
      StatisticsTable.resetData("combo-count");
      $(newLetter).remove();
    });
  }, timeInterval);

  $(document).on("keydown", function (e) {
    if (e.code === "ShiftLeft" && shiftKeyIsPressing !== "left") {
      shiftKeyIsPressing = "left";
    } else if (e.code === "ShiftRight" && shiftKeyIsPressing !== "right") {
      shiftKeyIsPressing = "right";
    }
  });

  $(document).on("keyup", function (e) {
    if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
      shiftKeyIsPressing = "";
      return;
    }

    const finger = KeyData.getFinger(e.key);
    if (finger) {
      const track = trackMap[finger];
      const firstChild = $(track).children().first();
      if (e.key === $(firstChild).text()) {
        if (checkLeftRightShift) {
          if (KeyData.data[e.key].shiftFinger !== shiftKeyIsPressing) {
            return;
          }
        }

        const top = parseInt($(firstChild).css("top").replace("px", ""));
        if (top >= perfectRange[0] && top <= perfectRange[1]) {
          StatisticsTable.addData("perfect-count");
          StatisticsTable.addData("combo-count");
          $(firstChild).stop().remove();
        } else {
          StatisticsTable.addData("good-count");
          StatisticsTable.addData("combo-count");
          $(firstChild).stop().remove();
        }
      }
    }
  });

  return intervalId;
}

// $(document).ready
$(function () {
  let intervalId = 0;
  let trackHeight = $("#track-container").height() ?? 0;
  let trackMap = {
    leftLittle: $("#left-little-track"),
    leftRing: $("#left-ring-track"),
    leftMiddle: $("#left-middle-track"),
    leftIndex: $("#left-index-track"),
    rightIndex: $("#right-index-track"),
    rightMiddle: $("#right-middle-track"),
    rightRing: $("#right-ring-track"),
    rightLittle: $("#right-little-track"),
  };

  CharacterSet.initializeClass();
  StatisticsTable.initializeClass();
  NumericalSetting.initializeClass();
  Game.initializeClass();

  $("#start-practice-btn").on("click", function () {
    if (intervalId === 0) {
      const kpm = NumericalSetting.getData("kpm");
      const letterSpeed = NumericalSetting.getData("letter-speed");
      const letterDivHeight = NumericalSetting.getData("letter-div-height");
      const checkLeftRightShift = Game.getSwitchSetting("check-left-right-shift");

      intervalId = startPractice(kpm, letterSpeed, letterDivHeight, trackMap, trackHeight, checkLeftRightShift);
      toggleSettingWhenStartOrStop("start");
    }
  });

  $("#stop-practice-btn").on("click", function () {
    if (intervalId !== 0) {
      window.clearInterval(intervalId);
      intervalId = 0;
    }
    $(document).off("keydown");
    $(document).off("keyup");

    $(".letter").stop().remove();
    toggleSettingWhenStartOrStop("stop");
  });
});

// #region for debugging

// let debugData = {};

// const lettersForEachFingerDebug = Object.freeze({
//     leftLittle: ["1", "q", "a", "z", "!", "Q", "A", "Z"],
//     leftRing: ["2", "w", "s", "x", "@", "W", "S", "X"],
//     leftMiddle: ["3", "e", "d", "c", "#", "E", "D", "C"],
//     leftIndex: ["4", "r", "f", "v", "5", "t", "g", "b", "$", "R", "F", "V", "%", "T", "G", "B"],
//     rightIndex: ["6", "y", "h", "n", "7", "u", "j", "m", "^", "Y", "H", "N", "&", "U", "J", "M"],
//     rightMiddle: ["8", "i", "k", ",", "*", "I", "K", "<"],
//     rightRing: ["9", "o", "l", ".", "(", "O", "L", ">"],
//     rightLittle: ["0", "p", ";", "/", ")", "P", ":", "?"],
// });

// /**
//  *
//  * @param {string} key
//  * @returns {string}
//  */
// function generateFinger(key) {
//     const finger = Object.keys(lettersForEachFingerDebug).find((finger) =>
//         lettersForEachFingerDebug[finger].includes(key)
//     );
//     return finger ?? "no-data";
// }

// $(document).on("keyup", function (e) {
//     console.log(e.key);
//     console.log(e);
//     const obj = {
//         key: e.key,
//         code: e.code,
//         shiftKey: e.shiftKey,
//         finger: generateFinger(e.key),
//         shiftFinger: e.shiftKey ? (generateFinger(e.key).includes("left") ? "left" : "right") : "",
//     };
//     debugData[e.key] = obj;
// });

// let all = Object.values(KeyData.data);
// console.log(`all.length`, all.length);

// let alphabet = [];
// let ALPHABET = [];
// let digit = [];
// let punctuation = [];

// for (let x of all) {
//     if (x.key.match(/[a-z]/)) {
//         alphabet.push(x);
//     } else if (x.key.match(/[A-Z]/)) {
//         ALPHABET.push(x);
//     } else if (x.key.match(/[0-9]/)) {
//         digit.push(x);
//     } else {
//         punctuation.push(x);
//     }
// }

// console.log(`alphabet`, alphabet);
// console.log(`ALPHABET`, ALPHABET);
// console.log(`digit`, digit);
// console.log(`punctuation`, punctuation);

// console.log(`alphabet.length`, alphabet.length);
// console.log(`ALPHABET.length`, ALPHABET.length);
// console.log(`digit.length`, digit.length);
// console.log(`punctuation.length`, punctuation.length);
// console.log(`sum of length`, alphabet.length + ALPHABET.length + digit.length + punctuation.length);

// function checkDigits() {
//     const digits = [];

//     for (let myKey in KeyData.data) {
//         if (KeyData.data[myKey].type === "digit") {
//             digits.push(KeyData.data[myKey]);
//         }
//     }

//     digits.sort((a, b) => parseInt(a.key) - parseInt(b.key));
//     console.log(
//         `checkDigits ~ digits.key`,
//         digits.map((x) => x.key)
//     );
//     console.log("check length", digits.length === 10);
//     console.log(
//         "check shift",
//         digits.every((x) => x.shiftKey === false && x.shiftFinger === "")
//     );
// }
// checkDigits();

// function checkAlphabet() {
//     const alphabet = [];

//     for (let myKey in KeyData.data) {
//         if (KeyData.data[myKey].type === "alphabet") {
//             alphabet.push(KeyData.data[myKey]);
//         }
//     }

//     alphabet.sort((a, b) => a.key.localeCompare(b.key));
//     console.log(
//         `checkAlphabet ~ alphabet.key`,
//         alphabet.map((x) => x.key)
//     );
//     console.log("check length", alphabet.length === 26);
//     console.log(
//         "check shift",
//         alphabet.every((x) => x.shiftKey === false && x.shiftFinger === "")
//     );
// }
// checkAlphabet();

// function checkALPHABET() {
//     const ALPHABET = [];

//     for (let myKey in KeyData.data) {
//         if (KeyData.data[myKey].type === "ALPHABET") {
//             ALPHABET.push(KeyData.data[myKey]);
//         }
//     }

//     ALPHABET.sort((a, b) => a.key.localeCompare(b.key));
//     console.log(
//         `checkALPHABET ~ ALPHABET.key`,
//         ALPHABET.map((x) => x.key)
//     );
//     console.log("check length", ALPHABET.length === 26);
//     console.log(
//         "check shift",
//         ALPHABET.every((x) => (x.shiftKey === true && x.shiftFinger === "left") || "right")
//     );
// }
// checkALPHABET();

// #endregion
